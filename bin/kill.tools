#!/bin/bash

# Protocol Tool 停止脚本
# 用于停止后台运行的 Go 后端服务

# 获取脚本所在目录，然后定位到项目根目录
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
ROOT_DIR="$(dirname "$SCRIPT_DIR")"
PID_FILE="$ROOT_DIR/.protocol-tool.pid"
BINARY_NAME="csv-parser"

# 自动设置 bin 目录下所有脚本的执行权限
chmod +x "$SCRIPT_DIR"/*.tools 2>/dev/null


# 函数：杀死进程及其子进程
kill_process_tree() {
    local pid=$1
    # 先获取所有子进程
    local children=$(pgrep -P "$pid" 2>/dev/null)
    for child in $children; do
        kill_process_tree "$child"
    done
    # 杀死当前进程
    kill "$pid" 2>/dev/null
}

# 检查 PID 文件是否存在
if [ ! -f "$PID_FILE" ]; then
    echo "PID file not found, searching by process name..."
    # 尝试按进程名查找并杀死
    PIDS=$(pgrep -f "$BINARY_NAME" 2>/dev/null)
    if [ -n "$PIDS" ]; then
        echo "Found related processes: $PIDS"
        for pid in $PIDS; do
            echo "Stopping process $pid..."
            kill "$pid" 2>/dev/null
        done
        sleep 1
        # 检查是否还有残留进程
        REMAINING=$(pgrep -f "$BINARY_NAME" 2>/dev/null)
        if [ -n "$REMAINING" ]; then
            echo "Force killing remaining processes..."
            for pid in $REMAINING; do
                kill -9 "$pid" 2>/dev/null
            done
        fi
        echo "✓ Service stopped"
    else
        echo "No running service found"
    fi
    exit 0
fi

# 读取 PID
PID=$(cat "$PID_FILE")

# 检查进程是否存在
if ! ps -p "$PID" > /dev/null 2>&1; then
    echo "Service process (PID: $PID) no longer exists"
    # 同时检查是否有按进程名运行的实例
    PIDS=$(pgrep -f "$BINARY_NAME" 2>/dev/null)
    if [ -n "$PIDS" ]; then
        echo "Found other related processes: $PIDS, stopping..."
        for pid in $PIDS; do
            kill "$pid" 2>/dev/null
        done
    fi
    rm -f "$PID_FILE"
    exit 0
fi

echo "Stopping Protocol Tool service (PID: $PID)..."

# 发送 SIGTERM 信号优雅关闭（包括子进程）
kill_process_tree "$PID"

# 等待进程结束（最多等待 10 秒）
for i in {1..10}; do
    if ! ps -p "$PID" > /dev/null 2>&1; then
        echo "✓ Service stopped successfully"
        rm -f "$PID_FILE"
        exit 0
    fi
    sleep 1
done

# 如果优雅关闭失败，强制终止
echo "Process not responding, force killing..."
kill -9 "$PID" 2>/dev/null

# 同时强制杀死可能残留的相关进程
pkill -9 -f "$BINARY_NAME" 2>/dev/null

sleep 1

if ! ps -p "$PID" > /dev/null 2>&1; then
    echo "✓ Service force stopped"
    rm -f "$PID_FILE"
else
    echo "✗ Failed to stop service, please handle manually (PID: $PID)"
    echo "  Try: kill -9 $PID"
    exit 1
fi
