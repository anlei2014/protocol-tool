#!/bin/bash

# Protocol Tool 启动脚本
# 用于在后台启动 Go 后端服务

# 获取脚本所在目录，然后定位到项目根目录
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
ROOT_DIR="$(dirname "$SCRIPT_DIR")"
BACKEND_DIR="$ROOT_DIR/backend"
BUILD_DIR="$ROOT_DIR/build"
PID_FILE="$ROOT_DIR/.protocol-tool.pid"
LOG_FILE="$ROOT_DIR/log/server.log"
BINARY_NAME="csv-parser"

# 自动设置 bin 目录下所有脚本的执行权限
chmod +x "$SCRIPT_DIR"/*.tools 2>/dev/null


# 检查是否已经在运行
if [ -f "$PID_FILE" ]; then
    OLD_PID=$(cat "$PID_FILE")
    if ps -p "$OLD_PID" > /dev/null 2>&1; then
        echo "Service is already running (PID: $OLD_PID)"
        echo "To restart, please run ./kill.tools first"
        exit 1
    else
        # PID 文件存在但进程不存在，清理旧的 PID 文件
        rm -f "$PID_FILE"
    fi
fi

# 确保日志目录和构建目录存在
mkdir -p "$ROOT_DIR/log"
mkdir -p "$BUILD_DIR"

# 切换到 backend 目录进行编译
cd "$BACKEND_DIR" || {
    echo "Error: Cannot enter backend directory: $BACKEND_DIR"
    exit 1
}

echo "Starting Protocol Tool service..."
echo "Project root: $ROOT_DIR"

# 编译 Go 程序到 build 目录
echo "Compiling..."
go build -o "$BUILD_DIR/$BINARY_NAME" . || {
    echo "Error: Build failed"
    exit 1
}

echo "Build completed: $BUILD_DIR/$BINARY_NAME"

# 切换到 build 目录运行（确保工作目录正确）
cd "$BUILD_DIR" || {
    echo "Error: Cannot enter build directory: $BUILD_DIR"
    exit 1
}

# 在后台运行编译后的二进制文件，输出重定向到日志文件
nohup ./"$BINARY_NAME" > "$LOG_FILE" 2>&1 &

# 保存 PID（这次是实际程序的 PID，不是 go run 的 PID）
PID=$!
echo $PID > "$PID_FILE"

# 等待一秒检查进程是否成功启动
sleep 1

if ps -p "$PID" > /dev/null 2>&1; then
    echo "✓ Service started successfully!"
    echo "  PID: $PID"
    echo "  Log file: $LOG_FILE"
    echo "  URL: http://localhost:8080"
    echo ""
    echo "Use ./kill.tools to stop the service"
else
    echo "✗ Service failed to start, please check log file: $LOG_FILE"
    rm -f "$PID_FILE"
    exit 1
fi
