#!/bin/bash

# Protocol Tool 启动脚本
# 用于在后台启动 Go 后端服务

# 获取脚本所在目录，然后定位到项目根目录
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
ROOT_DIR="$(dirname "$SCRIPT_DIR")"
BACKEND_DIR="$ROOT_DIR/backend"
BUILD_DIR="$ROOT_DIR/build"
PID_FILE="$ROOT_DIR/.protocol-tool.pid"
LOG_FILE="$ROOT_DIR/log/server.log"
BINARY_NAME="csv-parser"

# 检查是否已经在运行
if [ -f "$PID_FILE" ]; then
    OLD_PID=$(cat "$PID_FILE")
    if ps -p "$OLD_PID" > /dev/null 2>&1; then
        echo "服务已经在运行中 (PID: $OLD_PID)"
        echo "如需重启，请先运行 ./kill.tools"
        exit 1
    else
        # PID 文件存在但进程不存在，清理旧的 PID 文件
        rm -f "$PID_FILE"
    fi
fi

# 确保日志目录和构建目录存在
mkdir -p "$ROOT_DIR/log"
mkdir -p "$BUILD_DIR"

# 切换到 backend 目录进行编译
cd "$BACKEND_DIR" || {
    echo "错误: 无法进入 backend 目录: $BACKEND_DIR"
    exit 1
}

echo "正在启动 Protocol Tool 服务..."
echo "项目根目录: $ROOT_DIR"

# 编译 Go 程序到 build 目录
echo "正在编译..."
go build -o "$BUILD_DIR/$BINARY_NAME" . || {
    echo "错误: 编译失败"
    exit 1
}

echo "编译完成: $BUILD_DIR/$BINARY_NAME"

# 切换到 build 目录运行（确保工作目录正确）
cd "$BUILD_DIR" || {
    echo "错误: 无法进入 build 目录: $BUILD_DIR"
    exit 1
}

# 在后台运行编译后的二进制文件，输出重定向到日志文件
nohup ./"$BINARY_NAME" > "$LOG_FILE" 2>&1 &

# 保存 PID（这次是实际程序的 PID，不是 go run 的 PID）
PID=$!
echo $PID > "$PID_FILE"

# 等待一秒检查进程是否成功启动
sleep 1

if ps -p "$PID" > /dev/null 2>&1; then
    echo "✓ 服务启动成功!"
    echo "  PID: $PID"
    echo "  日志文件: $LOG_FILE"
    echo "  访问地址: http://localhost:8080"
    echo ""
    echo "使用 ./kill.tools 停止服务"
else
    echo "✗ 服务启动失败，请检查日志文件: $LOG_FILE"
    rm -f "$PID_FILE"
    exit 1
fi
